package io.sarl.demos.ants.gui

import io.sarl.demos.ants.Die
import io.sarl.core.OpenEventSpace
import java.awt.Color
import java.awt.Frame
import java.awt.Graphics
import java.awt.Image
import java.awt.Panel
import java.awt.^event.WindowAdapter
import java.awt.^event.WindowEvent
import java.util.Map
import java.util.UUID

import static extension java.lang.Math.*
import java.util.ArrayList
import java.awt.geom.Ellipse2D
import java.awt.Shape
import java.awt.Graphics2D
import io.sarl.demos.ants.Settings
import java.awt.Label
import java.awt.Font

/** 
 * Graphical user interface for ants.
 */
class EnvironmentGui extends Frame {

	var handler : Closer

	var panel : EnvironmentGuiPanel

	new (comspace : OpenEventSpace, iheight : int, iwidth : int,
		fileName : String, posList : ArrayList<double[]>) {
		super()
		handler = new Closer(this, comspace)
		panel = new EnvironmentGuiPanel(iheight, iwidth, posList)

		this.title = "TSP Simulation : " + fileName
		this.setSize(iwidth, iheight)
		addWindowListener(handler)

		add("Center", panel)
		this.visible = true
	}

	def setTour(tour : ArrayList<Integer>) {
		this.panel.tour = tour
	}
	
	def setTourLength(length : double)
	{
		this.panel.tourLength = length
	}
	
	def setIteration(iteration : int)
	{
		this.panel.iteration = iteration
	}

	override paint(g : Graphics) {
		super.paint(g)
		this.panel.paint(g)
	}

}

package class Closer extends WindowAdapter {
	var ^space : OpenEventSpace
	var iframe : Frame

	new(parent : Frame, comspace : OpenEventSpace) {
		^space = comspace
		iframe = parent
	}

	/** 
	 * Clean the simulation asking the agents to die before disposing the window
	 */
	override windowClosing(^event : WindowEvent) {
		^space.emit(UUID.randomUUID, new Die)
		iframe.dispose();
	}

}

/** 
 * The GUI of the Simulation
 */
package class EnvironmentGuiPanel extends Panel {

	/** 
	 * Double buffering management.
	 */
	var myGraphics : Graphics
	/** 
	 * Double buffering management.
	 */
	var myCanvas : Graphics
	/** 
	 * Double buffering management.
	 */
	var myImage : Image

	var width : int

	var height : int
	/**
	 * The list of town positions
	 */
	var posList : ArrayList<double[]>

	/**
	 * The tour between towns to print
	 */
	var tour : ArrayList<Integer>
	/**
	 * The tour length
	 */
	var tourLength : double
	
	var iteration : int

	def setTour(tour : ArrayList<Integer>) {
		this.tour = tour
	}
	
	def setTourLength(length : double)
	{
		this.tourLength = length
	}

	def setIteration(iteration : int) {
		this.iteration = iteration
	}

	/**
	 * Constructor
	 * @param iheight : int
	 */
	new (iheight : int, iwidth : int, _posList : ArrayList<double[]>) {
		super()
		width = iwidth
		height = iheight
		this.posList = _posList
	}

	override paint(g : Graphics) 
	{
		if ((myCanvas !== null) && (myGraphics !== null)) 
		{
			val bgColor = new Color(0.6F, 0.6F, 0.6F)
			myCanvas.color = bgColor
			myCanvas.fillRect(0, 0, width * 2 - 1, height * 2 - 1)
			myCanvas.setColor(Color::BLACK)
			myCanvas.drawRect(0, 0, width * 2 - 1, height * 2 - 1)
			
			var maxCoord : int = getMaxCoord(posList)
			
			//Draw the tour between towns and print the tour length
			if (this.tour !== null) 
			{
				for (var i = 0; i < this.tour.size; i++)
					this.tour.set(i, this.tour.get(i) + 1)
					
				var linePixelList : ArrayList<int[]> = getRectPixel(this.posList, this.tour, maxCoord)
				for (line : linePixelList) 
					myCanvas.drawLine(line.get(0), line.get(1), line.get(2), line.get(3))
				myCanvas.drawString("Tour length : " + tourLength as int as String, Settings.EnvtWidth - 300, Settings.EnvtHeight - 60)
				myCanvas.drawString("Number of remaining iterations (over " + Settings.iteration as String + ") : " 
					+ (Settings.iteration - iteration) as String, 
					0, Settings.EnvtHeight - 60
				)
				myCanvas.setFont(new Font("Arial", Font.PLAIN, 24))
			}
			
			for (pos : posList) 
				paintTown(myCanvas as Graphics2D, pos, maxCoord)

			myGraphics.drawImage(myImage, 0, 0, this)
		}
	}

	def update(g : Graphics) {
		g.paint
	}

 	override doLayout {
		super.doLayout

		width = (this.size.width / 2)
		height = this.size.height / 2

		myImage = createImage(width * 2, height * 2)
		myCanvas = myImage.graphics
		myGraphics = this.graphics
	}

	/**
	 * Paint on the graphic every town in the position list
	 * @param g : Graphics2D, the graphic we print in
	 * @param pos : double[], the list containing the town positions
	 * @param maxCoord : int, the maximum coordinate to do the resizing
	 */
	def paintTown(g : Graphics2D, pos : double[], maxCoord : int) 
	{
		var coord : double[] = newDoubleArrayOfSize(2)
		coord.set(0, pos.get(1))
		coord.set(1, pos.get(2))
		var pixel : int[] = pixelResizing(coord, maxCoord)

		var circle : Shape = new Ellipse2D.Double(pixel.get(0) - 8, pixel.get(1) - 8, 16, 16);

		g.color = Color.RED
		g.fill(circle)
		g.draw(circle)
	}
	
	/**
	 * Return the maximum coordinate you can find in the position list
	 * @param posList : ArrayList<double[]> the list of position of every town
	 * @return int : the maximum coordinate
	 */
	private def getMaxCoord(posList : ArrayList<double[]>) : int
	{
		var max : double = 0
		for(pos : posList)
		{
			if(pos.get(1) > max)
				max = pos.get(1)
			if(pos.get(2) > max)
				max = pos.get(2)
		}
		return max as int
	}
	
	/**
	 * Return the pixel value based on the size of the screen and the maximum coordinate
	 * @param coord : double[], the coordinate to translate in pixel, X and Y
	 * @param maxCoord : int, the biggest coordinate in the list
	 * @return int[2], the pixels to print 
	 */
	private def pixelResizing(coord : double[], maxCoord : int) : int[]
	{
		var result : int[] = newIntArrayOfSize(2)
		result.set(0, (coord.get(0) * (Settings.EnvtWidth - 100) / maxCoord + 25) as int)
		result.set(1, (coord.get(1) * (Settings.EnvtHeight - 100) / maxCoord + 25) as int)
		return result
	}
	
	/**
	 * Find a town coordinates from its ID in the position list
	 * @param posList : ArrayList<double[]>, the position list
	 * @param id : int, the ID of the town to find
	 * @return double[2], the town coordinates
	 */
	private def getCoordFromTownId(posList : ArrayList<double[]>, id : int) : double[]
	{
		var result : double[] = newDoubleArrayOfSize(2)
		var i : int = 0
		while(i < posList.size - 1 && (posList.get(i).get(0) as int) != id)
		{
			i++
		}

		if(posList.get(i).get(0) as int == id)
		{
			result.set(0, posList.get(i).get(1))
			result.set(1, posList.get(i).get(2))
		}
		else
			System.out.println("Error, coordinate not found with this ID")
		return result
	}
	
	/**
	 * Return the coordinates of the pixel of the rectangle to draw between each town
	 * @param posList : ArrayList<double[]> : the position list of every town
	 * @param travelorder : ArrayList<Integer> : the path between the town
	 * @param maxCoord : int, the max coordinate to do the resizing
	 * @return ArrayList<int[]> : the pixel list of each corner of the rectangle to drawa
	 */
	 private def getRectPixel(posList : ArrayList<double[]>, travelOrder : ArrayList<Integer>, maxCoord : int) : ArrayList<int[]>
	 {
	 	var rectPixelList : ArrayList<int[]> = new ArrayList<int[]>()
	 	var size : int = travelOrder.size
	 	
	 	for(var i : int = 0; i < size - 1; i++)
	 	{
	 		var intArray : int[] = newIntArrayOfSize(4)
	 		var coord1 : double[] = getCoordFromTownId(posList, travelOrder.get(i))
	 		var coord2 : double[] = getCoordFromTownId(posList, travelOrder.get(i + 1))
	 		
	 		var pixel1 : int[] = pixelResizing(coord1, maxCoord)
			var pixel2 : int[] = pixelResizing(coord2, maxCoord)
	 		intArray.set(0, pixel1.get(0))
			intArray.set(1, pixel1.get(1))
			intArray.set(2, pixel2.get(0))
			intArray.set(3, pixel2.get(1))
			rectPixelList.add(intArray)
	 	}
	 	
	 	//Add the last line from the first to the last town in the list
		var intArray : int[] = newIntArrayOfSize(4)
		var coord1 : double[] = getCoordFromTownId(posList, travelOrder.get(size - 1))
		var coord2 : double[] = getCoordFromTownId(posList, travelOrder.get(0))

		var pixel1 : int[] = pixelResizing(coord1, maxCoord)
		var pixel2 : int[] = pixelResizing(coord2, maxCoord)
		intArray.set(0, pixel1.get(0))
		intArray.set(1, pixel1.get(1))
		intArray.set(2, pixel2.get(0))
		intArray.set(3, pixel2.get(1))
		rectPixelList.add(intArray)
		
	 	return rectPixelList
	 }
}
