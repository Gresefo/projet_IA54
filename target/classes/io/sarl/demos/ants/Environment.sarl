package io.sarl.demos.ants

import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.Schedules
import java.util.UUID
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ConcurrentSkipListSet

import org.eclipse.xtend.lib.annotations.Accessors
import io.sarl.core.Lifecycle
import java.util.ArrayList
import java.util.concurrent.CopyOnWriteArrayList

/** 
 * The environmental agent in charge of collecting ants influences and computing the new state of the virtual world
 */
agent Environment {

	uses Logging, DefaultContextInteractions, Schedules, Lifecycle

	@Accessors
	var width : int

	@Accessors
	var height : int

	// @Accessors
	// var ants : ConcurrentHashMap<UUID, PerceivedAntBody>

	// Set of ants ID who has sent their influence in the current time step
	@Accessors
	var distMatrix : double[][]

	var numberAnts : int

	var pheromons : double[][]

	var nnTourLength : double

	/**
	 * A thread safe List<Pair> to store the list of :
	 * 	- List<Integer> : the path with the town ID
	 *  - Double : the path length
	 */
	var tourArray : CopyOnWriteArrayList<Pair<ArrayList<Integer>, Double>>

	/**
	 * The current iteration number 
	 */
	var iteration : int
	
	/**
	 * Used to check if the result converged
	 */
	var lastTour : ArrayList<Double>

	on Initialize {
		loggingName = "Environment"
		// Environment init parameters : An Integer the grid's height, An integer the grid's width
		if (occurrence.parameters.size > 1) {
			if (occurrence.parameters.get(0) instanceof Integer) {
				height = occurrence.parameters.get(0) as Integer
			}

			if (occurrence.parameters.get(1) instanceof Integer) {
				width = occurrence.parameters.get(1) as Integer
			}
			if (occurrence.parameters.get(2) instanceof double[][]) {
				distMatrix = occurrence.parameters.get(2) as double[][]
			}
			if (occurrence.parameters.get(3) instanceof Integer) {
				numberAnts = occurrence.parameters.get(3) as Integer
			}
		}
		if (Settings::isLogActivated) {
			"Environment activated".info
		}
	}

	on StartEnvironment {
		info("ENV STARTED")
		this.tourArray = new CopyOnWriteArrayList<Pair<ArrayList<Integer>, Double>>
		this.lastTour = new ArrayList<Double>
		
		this.iteration = 0
		this.nnTourLength = nearestNeighbour(this.distMatrix)

		var size = this.distMatrix.length
		pheromons = newDoubleArrayOfSize(size, size)
		for (var i = 0; i < size; i++) {
			for (var j = 0; j < size; j++) {
				if (i == j) {
					this.pheromons.set(i, j, 0.0)
				} else {
					this.pheromons.set(i, j, this.numberAnts / this.nnTourLength)
				}
			}
		}

		new StartAnt(this.pheromons).emit
	}

	on TourFound {
		synchronized (this.tourArray) {
			this.tourArray.add(new Pair(occurrence.tour, occurrence.length))

			if (this.tourArray.size == this.numberAnts) {
				var phero : double
				var min : double = this.tourArray.get(0).getValue
				var indexBestTour = 0
				var k = 0
				
				// Pheromone evaporation
				for (var i = 0; i < this.numberAnts; i++) {
					for (var j = 0; j < this.numberAnts; j++) {
						if (i != j) {
							phero = this.pheromons.get(i, j) * (1 - Settings::rho)
							this.pheromons.set(i, j, phero)
						}
					}
				}
				
				// Get shortest path and update pheromons
				for (tA : this.tourArray) {
					// Gets shortest path
					if (tA.getValue < min) {
						min = tA.getValue
						indexBestTour = k
					}
					k++
					// Update the pheromons matrix, increase visited path depending on the path length
					phero = 1 / tA.getValue
					for (var i = 0; i < this.numberAnts - 1; i++) {
						this.pheromons.set(tA.getKey.get(i), 
											tA.getKey.get(i + 1), 
											this.pheromons.get(tA.getKey.get(i), tA.getKey.get(i + 1)) + phero
						)
					}
				}
				
				info("Best tour : " + this.tourArray.get(indexBestTour).getValue)
				
				// Send event to repaint
				var tmpList : ArrayList<Integer> = new ArrayList<Integer>()
				for (var i = 0; i < this.tourArray.get(indexBestTour).getKey.size; i++)
					tmpList.add(this.tourArray.get(indexBestTour).getKey.get(i) + 1)
				new GuiRepaint(tmpList, this.tourArray.get(indexBestTour).getValue, this.iteration).emit [
					it.UUID == Simulation.id
				]
				
				// If last iteration, kill all
				if (this.iteration == Settings::iteration) {
					printDistMatrix(this.pheromons, 25)
					
					info("KILL AGENTS")
					info("Tour : " + this.tourArray.get(indexBestTour).getKey)
					new Die().emit
				}
				else {
					var size = this.lastTour.size
					// Check convergence
					if (size >= Settings::nbIterationToConverge) {
						var same = 0
						for (var i = size - Settings::nbIterationToConverge; i < size; i++) {
							if(Math.abs(this.tourArray.get(indexBestTour).getValue - this.lastTour.get(i)) < 1.0) {
								same++
							}
						}
						if (same == Settings::nbIterationToConverge) {
							info("Stopped at iteration : " + this.iteration)
							this.iteration = Settings::iteration - 1
						}
					}
					this.lastTour.add(this.tourArray.get(indexBestTour).getValue)
				}

				this.tourArray.clear
				this.iteration++
				new StartAnt(this.pheromons).emit
			}
		}
	}

	on Die {
		killMe
	}

	/**
	 * Calculate a tour using the nearest neighbor algo
	 * @param
	 * 
	 */
	def nearestNeighbour(distMatrix : double[][]) : double {
		var tourLength = 0.0
		var size = this.distMatrix.length

		var tour : ArrayList<Integer> = new ArrayList<Integer>
		var citiesToVisit : ArrayList<Integer> = new ArrayList<Integer>
		for (var i = 1; i < size; i++) {
			citiesToVisit.add(i)
		}

		tour.add(0)
		var currentCity = 0
		var index = 0
		var min = 0.0

		while (tour.size != size) {
			if (currentCity == 0) {
				min = distMatrix.get(currentCity, 1)
				index = 1
			} else {
				min = distMatrix.get(currentCity, 0)
				index = 0
			}
			for (i : citiesToVisit) {
				if (distMatrix.get(currentCity, i) < min) {
					min = distMatrix.get(currentCity, i)
					index = i
				}
			}
			tourLength += distMatrix.get(currentCity, index)
			currentCity = index
			tour.add(currentCity)
			citiesToVisit.remove(currentCity as Integer)
		}
		tourLength += distMatrix.get(currentCity, 0)
		return tourLength
	}

	def printDistMatrix(distMatrix : double[][], maxSize : int) : void {
		var maxSize2 : int = maxSize
		if (maxSize > distMatrix.size)
			maxSize2 = distMatrix.size
	
		System.out.println("Pheromone Matrix (size printed: " + maxSize2 + "):")
		for (var i : int = 0; i < maxSize2; i++) {
			for (var j : int = 0; j < maxSize2; j++) {
				System.out.print(" " + distMatrix.get(i).get(j) as double)
				if (distMatrix.get(i).get(j) < 10)
					System.out.print("    ")
				else if (distMatrix.get(i).get(j) < 100)
					System.out.print("   ")
				else if (distMatrix.get(i).get(j) < 1000)
					System.out.print("  ")
				else if (distMatrix.get(i).get(j) < 10000)
					System.out.print(" ")
			}
			System.out.println()
		}
		
	}

}
