
package io.sarl.demos.ants

import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.Schedules
import java.util.UUID
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ConcurrentSkipListSet

import org.eclipse.xtend.lib.annotations.Accessors
import io.sarl.core.Lifecycle
import java.util.ArrayList

/** 
 * The environmental agent in charge of collecting ants influences and computing the new state of the virtual world
 */
agent Environment {

	uses Logging, DefaultContextInteractions, Schedules, Lifecycle

	@Accessors
	var width : int

	@Accessors
	var height : int

	//@Accessors
	//var ants : ConcurrentHashMap<UUID, PerceivedAntBody>

	// Set of ants ID who has sent their influence in the current time step
	@Accessors
	var influences : ConcurrentSkipListSet<UUID>
	
	var distMatrix : double[][]
	
	var numberAnts : int
	
	var pheromons : double[][]
	
	var nnTourLength : double

	on Initialize 
	{
		loggingName = "Environment"
		// Environment init parameters : An Integer the grid's height, An integer the grid's width
		if (occurrence.parameters.size > 1) {
			if (occurrence.parameters.get(0) instanceof Integer) {
				height = occurrence.parameters.get(0) as Integer
			}

			if (occurrence.parameters.get(1) instanceof Integer) {
				width = occurrence.parameters.get(1) as Integer
			}
			if (occurrence.parameters.get(2) instanceof double[][]) {
				distMatrix = occurrence.parameters.get(2) as double[][]
			}
			if (occurrence.parameters.get(3) instanceof Integer) {
				numberAnts = occurrence.parameters.get(3) as Integer
			}
			influences = new ConcurrentSkipListSet
		}
		if (Settings::isLogActivated) {
			"Environment activated".info
			info(this.distMatrix.get(0, 1))
		}
	}

	on StartEnvironment {
		/*this.ants = occurrence.perceivedAgentBody
		new GuiRepaint(ants).emit
		new Perception(ants).emit*/
		info("ENV STARTED")
		
		this.nnTourLength = nearestNeighbour(this.distMatrix)

		var size = this.distMatrix.length
		pheromons = newDoubleArrayOfSize(size, size)
		for (var i = 0; i < size; i++) {
			for (var j = 0; j < size; j++) {
				if (i == j) {
					this.pheromons.set(i, j, 0.0)
				}
				else {
					this.pheromons.set(i, j, this.numberAnts / this.nnTourLength)
				}
			}
		}
		
	}

	on Action 
	{
		// TODO 5 Complete Environment behavior : collecting influences from all agents, updating environmental state, sending perceptions, refreshing GUI
        synchronized (influences) 
		{
			if (ants.containsKey(occurrence.source.UUID)) {
				this.influences.add(occurrence.source.UUID)
				applyForce(occurrence.influence, ants.get(occurrence.source.UUID))
			}
				if (this.influences.size == this.ants.size) 
			{
				in(Settings::pause) [
					new GuiRepaint(ants).emit[it.UUID == Simulation.id]
					new Perception(ants).emit
					if (Settings::isLogActivated) 
					{
						info("New Simulation Step.")
                       }
                   ]
                   this.influences.clear
			}
		}
	}

	on Die {
		killMe
	}
	
	def nearestNeighbour(distMatrix : double[][]) : double{
		var tourLength = 0.0
		var size = this.distMatrix.length
		
		var tour : ArrayList<Integer> = new ArrayList<Integer>
		var citiesToVisit : ArrayList<Integer> = new ArrayList<Integer>
		for (var i = 1; i < size; i++) {
			citiesToVisit.add(i)
		}
		
		tour.add(0)
		var currentCity = 0
		var index = 0
		var min = 0.0
		
		while(tour.size != size) {
			if (currentCity == 0) {
				min = distMatrix.get(currentCity, 1)
				index = 1
			}
			else {
				min = distMatrix.get(currentCity, 0)
				index = 0
			}
			for(i : citiesToVisit) {
				if (distMatrix.get(currentCity, i) < min) {
					min = distMatrix.get(currentCity, i)
					index = i
				}
			}
			tourLength += distMatrix.get(currentCity, index)
			currentCity = index
			tour.add(currentCity)
			citiesToVisit.remove(currentCity as Integer)
		}
		
		return tourLength
	}
	
	def applyForce(force : Vector2d, b : PerceivedAntBody) {
		// limiting/clamping the applied force
		if (force.length > b.group.maxForce) {
			force.length = b.group.maxForce
		}

		// contribution of the mass.
		// force * (1 / b.getGroupe().masse);
		// updating acceleration and speed.
		var acceleration = b.acceleration
		acceleration.set(force)
		var vitesse = b.vitesse
		vitesse += acceleration

		// updating speed
		if (vitesse.length > b.group.maxSpeed) {
			vitesse.length = b.group.maxSpeed
		}

		// updating the position
		var position = b.position
		position += vitesse

		var bb = ants.get(b.owner)
		bb.acceleration = acceleration
		bb.vitesse = vitesse
		bb.position = position

		// we adjust it according to the dimensions of the World.
		b.clampToWorld
	}

	/** 
	 * The world is circular, this function clamps coordinates to stay within the frame
	 */
	def clampToWorld(b : PerceivedAntBody) {
		var posX = b.position.x
		var posY = b.position.y

		if (posX > width / 2) {
			posX -= width
		}
		if (posX < ( -1 * width / 2 )) {
			posX += width
		}
		if (posY > height / 2) {
			posY -= height
		}
		if (posY < ( -1 * height / 2 )) {
			posY += height
		}

		ants.get(b.owner).position = new Vector2d(posX, posY)
	}

}
